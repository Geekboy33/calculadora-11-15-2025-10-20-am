{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-56ae0a0da09da2f0744d1a33f0a41ec0aaa5a983",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/FlashLoanArbitrage.sol": "project/contracts/FlashLoanArbitrage.sol",
    "contracts/MultiDexExecutor.sol": "project/contracts/MultiDexExecutor.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/FlashLoanArbitrage.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n * 汳ｰ FLASH LOAN ARBITRAGE CONTRACT\r\n * 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n * \r\n * Este contrato ejecuta arbitraje atﾃｳmico usando Flash Loans de Aave V3.\r\n * Soporta mﾃｺltiples DEXs: Uniswap V3, SushiSwap, Curve\r\n * \r\n * Caracterﾃｭsticas:\r\n * - Flash Loans sin colateral de Aave V3\r\n * - Arbitraje multi-DEX atﾃｳmico\r\n * - MEV Protection (deadline, slippage)\r\n * - Profit validation antes de ejecutar\r\n */\r\n\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n// INTERFACES\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n\r\ninterface IPoolAddressesProvider {\r\n    function getPool() external view returns (address);\r\n}\r\n\r\ninterface IPool {\r\n    function flashLoanSimple(\r\n        address receiverAddress,\r\n        address asset,\r\n        uint256 amount,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n}\r\n\r\ninterface IFlashLoanSimpleReceiver {\r\n    function executeOperation(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256) external;\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n    \r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n    \r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n    \r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\ninterface ISushiRouter {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n}\r\n\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n// MAIN CONTRACT\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n\r\ncontract FlashLoanArbitrage is IFlashLoanSimpleReceiver {\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // STATE VARIABLES\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    address public owner;\r\n    address public immutable POOL_ADDRESSES_PROVIDER;\r\n    address public immutable AAVE_POOL;\r\n    \r\n    // DEX Routers\r\n    address public uniswapV3Router;\r\n    address public sushiRouter;\r\n    \r\n    // Token addresses (set per chain)\r\n    address public WETH;\r\n    address public USDC;\r\n    address public USDT;\r\n    address public DAI;\r\n    \r\n    // Stats\r\n    uint256 public totalFlashLoans;\r\n    uint256 public totalProfitWei;\r\n    uint256 public successfulArbitrages;\r\n    \r\n    // Safety\r\n    uint256 public minProfitBps = 10; // 0.1% minimum profit\r\n    uint256 public maxSlippageBps = 100; // 1% max slippage\r\n    bool public paused = false;\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // EVENTS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    event FlashLoanExecuted(address indexed asset, uint256 amount, uint256 premium, uint256 profit);\r\n    event ArbitrageExecuted(string strategy, uint256 amountIn, uint256 amountOut, uint256 profit);\r\n    event ProfitWithdrawn(address indexed to, uint256 amount);\r\n    event ConfigUpdated(string param, uint256 value);\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // MODIFIERS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier notPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPool() {\r\n        require(msg.sender == AAVE_POOL, \"Only Aave Pool\");\r\n        _;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // CONSTRUCTOR\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    constructor(\r\n        address _poolAddressesProvider,\r\n        address _uniswapV3Router,\r\n        address _sushiRouter,\r\n        address _weth,\r\n        address _usdc\r\n    ) {\r\n        owner = msg.sender;\r\n        POOL_ADDRESSES_PROVIDER = _poolAddressesProvider;\r\n        AAVE_POOL = IPoolAddressesProvider(_poolAddressesProvider).getPool();\r\n        \r\n        uniswapV3Router = _uniswapV3Router;\r\n        sushiRouter = _sushiRouter;\r\n        WETH = _weth;\r\n        USDC = _usdc;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // FLASH LOAN ENTRY POINT\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Initiate a flash loan for arbitrage\r\n     * @param asset Token to borrow\r\n     * @param amount Amount to borrow\r\n     * @param params Encoded arbitrage parameters\r\n     */\r\n    function executeFlashLoan(\r\n        address asset,\r\n        uint256 amount,\r\n        bytes calldata params\r\n    ) external onlyOwner notPaused {\r\n        IPool(AAVE_POOL).flashLoanSimple(\r\n            address(this),\r\n            asset,\r\n            amount,\r\n            params,\r\n            0 // referral code\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Aave callback - execute arbitrage with borrowed funds\r\n     */\r\n    function executeOperation(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 premium,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external override onlyPool returns (bool) {\r\n        require(initiator == address(this), \"Invalid initiator\");\r\n        \r\n        uint256 balanceBefore = IERC20(asset).balanceOf(address(this));\r\n        \r\n        // Decode and execute arbitrage strategy\r\n        (uint8 strategy, bytes memory strategyParams) = abi.decode(params, (uint8, bytes));\r\n        \r\n        uint256 amountOut;\r\n        \r\n        if (strategy == 1) {\r\n            // Intra-DEX arbitrage (different fee tiers)\r\n            amountOut = _executeIntraDexArbitrage(asset, amount, strategyParams);\r\n        } else if (strategy == 2) {\r\n            // Cross-DEX arbitrage (Uniswap vs Sushi)\r\n            amountOut = _executeCrossDexArbitrage(asset, amount, strategyParams);\r\n        } else if (strategy == 3) {\r\n            // Triangular arbitrage\r\n            amountOut = _executeTriangularArbitrage(asset, amount, strategyParams);\r\n        } else {\r\n            revert(\"Invalid strategy\");\r\n        }\r\n        \r\n        uint256 balanceAfter = IERC20(asset).balanceOf(address(this));\r\n        uint256 totalDebt = amount + premium;\r\n        \r\n        require(balanceAfter >= totalDebt, \"Insufficient funds to repay\");\r\n        \r\n        uint256 profit = balanceAfter - totalDebt;\r\n        \r\n        // Verify minimum profit\r\n        uint256 minProfit = (amount * minProfitBps) / 10000;\r\n        require(profit >= minProfit, \"Profit below minimum\");\r\n        \r\n        // Approve repayment\r\n        IERC20(asset).approve(AAVE_POOL, totalDebt);\r\n        \r\n        // Update stats\r\n        totalFlashLoans++;\r\n        totalProfitWei += profit;\r\n        successfulArbitrages++;\r\n        \r\n        emit FlashLoanExecuted(asset, amount, premium, profit);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // ARBITRAGE STRATEGIES\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Strategy 1: Intra-DEX arbitrage between fee tiers\r\n     * Example: Buy on 0.05% pool, sell on 0.3% pool\r\n     */\r\n    function _executeIntraDexArbitrage(\r\n        address asset,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) internal returns (uint256) {\r\n        (\r\n            address tokenOut,\r\n            uint24 fee1,\r\n            uint24 fee2\r\n        ) = abi.decode(params, (address, uint24, uint24));\r\n        \r\n        // Approve router\r\n        IERC20(asset).approve(uniswapV3Router, amount);\r\n        \r\n        // Swap 1: asset -> tokenOut (fee1)\r\n        uint256 intermediateAmount = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: asset,\r\n                tokenOut: tokenOut,\r\n                fee: fee1,\r\n                recipient: address(this),\r\n                amountIn: amount,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        // Approve for second swap\r\n        IERC20(tokenOut).approve(uniswapV3Router, intermediateAmount);\r\n        \r\n        // Swap 2: tokenOut -> asset (fee2)\r\n        uint256 finalAmount = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: tokenOut,\r\n                tokenOut: asset,\r\n                fee: fee2,\r\n                recipient: address(this),\r\n                amountIn: intermediateAmount,\r\n                amountOutMinimum: amount, // At least get back what we started with\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        emit ArbitrageExecuted(\"INTRA_DEX\", amount, finalAmount, finalAmount > amount ? finalAmount - amount : 0);\r\n        \r\n        return finalAmount;\r\n    }\r\n    \r\n    /**\r\n     * @notice Strategy 2: Cross-DEX arbitrage (Uniswap V3 vs SushiSwap)\r\n     */\r\n    function _executeCrossDexArbitrage(\r\n        address asset,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) internal returns (uint256) {\r\n        (\r\n            address tokenOut,\r\n            uint24 uniFee,\r\n            bool buyOnUni // true = buy on Uni, sell on Sushi\r\n        ) = abi.decode(params, (address, uint24, bool));\r\n        \r\n        uint256 finalAmount;\r\n        \r\n        if (buyOnUni) {\r\n            // Buy on Uniswap V3\r\n            IERC20(asset).approve(uniswapV3Router, amount);\r\n            \r\n            uint256 intermediateAmount = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n                ISwapRouter.ExactInputSingleParams({\r\n                    tokenIn: asset,\r\n                    tokenOut: tokenOut,\r\n                    fee: uniFee,\r\n                    recipient: address(this),\r\n                    amountIn: amount,\r\n                    amountOutMinimum: 0,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            );\r\n            \r\n            // Sell on SushiSwap\r\n            IERC20(tokenOut).approve(sushiRouter, intermediateAmount);\r\n            \r\n            address[] memory path = new address[](2);\r\n            path[0] = tokenOut;\r\n            path[1] = asset;\r\n            \r\n            uint[] memory amounts = ISushiRouter(sushiRouter).swapExactTokensForTokens(\r\n                intermediateAmount,\r\n                amount, // minimum output\r\n                path,\r\n                address(this),\r\n                block.timestamp + 300\r\n            );\r\n            \r\n            finalAmount = amounts[amounts.length - 1];\r\n        } else {\r\n            // Buy on SushiSwap\r\n            IERC20(asset).approve(sushiRouter, amount);\r\n            \r\n            address[] memory path = new address[](2);\r\n            path[0] = asset;\r\n            path[1] = tokenOut;\r\n            \r\n            uint[] memory amounts = ISushiRouter(sushiRouter).swapExactTokensForTokens(\r\n                amount,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp + 300\r\n            );\r\n            \r\n            uint256 intermediateAmount = amounts[amounts.length - 1];\r\n            \r\n            // Sell on Uniswap V3\r\n            IERC20(tokenOut).approve(uniswapV3Router, intermediateAmount);\r\n            \r\n            finalAmount = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n                ISwapRouter.ExactInputSingleParams({\r\n                    tokenIn: tokenOut,\r\n                    tokenOut: asset,\r\n                    fee: uniFee,\r\n                    recipient: address(this),\r\n                    amountIn: intermediateAmount,\r\n                    amountOutMinimum: amount,\r\n                    sqrtPriceLimitX96: 0\r\n                })\r\n            );\r\n        }\r\n        \r\n        emit ArbitrageExecuted(\"CROSS_DEX\", amount, finalAmount, finalAmount > amount ? finalAmount - amount : 0);\r\n        \r\n        return finalAmount;\r\n    }\r\n    \r\n    /**\r\n     * @notice Strategy 3: Triangular arbitrage (A -> B -> C -> A)\r\n     */\r\n    function _executeTriangularArbitrage(\r\n        address asset,\r\n        uint256 amount,\r\n        bytes memory params\r\n    ) internal returns (uint256) {\r\n        (\r\n            address tokenB,\r\n            address tokenC,\r\n            uint24 feeAB,\r\n            uint24 feeBC,\r\n            uint24 feeCA\r\n        ) = abi.decode(params, (address, address, uint24, uint24, uint24));\r\n        \r\n        // Approve router\r\n        IERC20(asset).approve(uniswapV3Router, amount);\r\n        \r\n        // Swap 1: A -> B\r\n        uint256 amountB = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: asset,\r\n                tokenOut: tokenB,\r\n                fee: feeAB,\r\n                recipient: address(this),\r\n                amountIn: amount,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        // Approve B\r\n        IERC20(tokenB).approve(uniswapV3Router, amountB);\r\n        \r\n        // Swap 2: B -> C\r\n        uint256 amountC = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: tokenB,\r\n                tokenOut: tokenC,\r\n                fee: feeBC,\r\n                recipient: address(this),\r\n                amountIn: amountB,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        // Approve C\r\n        IERC20(tokenC).approve(uniswapV3Router, amountC);\r\n        \r\n        // Swap 3: C -> A\r\n        uint256 finalAmount = ISwapRouter(uniswapV3Router).exactInputSingle(\r\n            ISwapRouter.ExactInputSingleParams({\r\n                tokenIn: tokenC,\r\n                tokenOut: asset,\r\n                fee: feeCA,\r\n                recipient: address(this),\r\n                amountIn: amountC,\r\n                amountOutMinimum: amount,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        emit ArbitrageExecuted(\"TRIANGULAR\", amount, finalAmount, finalAmount > amount ? finalAmount - amount : 0);\r\n        \r\n        return finalAmount;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // DIRECT ARBITRAGE (NO FLASH LOAN)\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Execute arbitrage with contract's own funds (no flash loan)\r\n     */\r\n    function executeDirectArbitrage(\r\n        address asset,\r\n        uint256 amount,\r\n        uint8 strategy,\r\n        bytes calldata strategyParams\r\n    ) external onlyOwner notPaused returns (uint256 profit) {\r\n        uint256 balanceBefore = IERC20(asset).balanceOf(address(this));\r\n        require(balanceBefore >= amount, \"Insufficient balance\");\r\n        \r\n        uint256 amountOut;\r\n        \r\n        if (strategy == 1) {\r\n            amountOut = _executeIntraDexArbitrage(asset, amount, strategyParams);\r\n        } else if (strategy == 2) {\r\n            amountOut = _executeCrossDexArbitrage(asset, amount, strategyParams);\r\n        } else if (strategy == 3) {\r\n            amountOut = _executeTriangularArbitrage(asset, amount, strategyParams);\r\n        } else {\r\n            revert(\"Invalid strategy\");\r\n        }\r\n        \r\n        uint256 balanceAfter = IERC20(asset).balanceOf(address(this));\r\n        \r\n        require(balanceAfter > balanceBefore, \"No profit\");\r\n        profit = balanceAfter - balanceBefore;\r\n        \r\n        // Verify minimum profit\r\n        uint256 minProfit = (amount * minProfitBps) / 10000;\r\n        require(profit >= minProfit, \"Profit below minimum\");\r\n        \r\n        totalProfitWei += profit;\r\n        successfulArbitrages++;\r\n        \r\n        return profit;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // ADMIN FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    function setTokens(address _weth, address _usdc, address _usdt, address _dai) external onlyOwner {\r\n        WETH = _weth;\r\n        USDC = _usdc;\r\n        USDT = _usdt;\r\n        DAI = _dai;\r\n    }\r\n    \r\n    function setRouters(address _uniRouter, address _sushiRouter) external onlyOwner {\r\n        uniswapV3Router = _uniRouter;\r\n        sushiRouter = _sushiRouter;\r\n    }\r\n    \r\n    function setMinProfitBps(uint256 _minProfitBps) external onlyOwner {\r\n        require(_minProfitBps <= 1000, \"Max 10%\");\r\n        minProfitBps = _minProfitBps;\r\n        emit ConfigUpdated(\"minProfitBps\", _minProfitBps);\r\n    }\r\n    \r\n    function setMaxSlippageBps(uint256 _maxSlippageBps) external onlyOwner {\r\n        require(_maxSlippageBps <= 500, \"Max 5%\");\r\n        maxSlippageBps = _maxSlippageBps;\r\n        emit ConfigUpdated(\"maxSlippageBps\", _maxSlippageBps);\r\n    }\r\n    \r\n    function setPaused(bool _paused) external onlyOwner {\r\n        paused = _paused;\r\n    }\r\n    \r\n    function withdrawProfit(address token) external onlyOwner {\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n        require(balance > 0, \"No balance\");\r\n        IERC20(token).transfer(owner, balance);\r\n        emit ProfitWithdrawn(owner, balance);\r\n    }\r\n    \r\n    function withdrawETH() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No ETH\");\r\n        payable(owner).transfer(balance);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // VIEW FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    function getStats() external view returns (\r\n        uint256 _totalFlashLoans,\r\n        uint256 _totalProfitWei,\r\n        uint256 _successfulArbitrages\r\n    ) {\r\n        return (totalFlashLoans, totalProfitWei, successfulArbitrages);\r\n    }\r\n    \r\n    function getConfig() external view returns (\r\n        uint256 _minProfitBps,\r\n        uint256 _maxSlippageBps,\r\n        bool _paused\r\n    ) {\r\n        return (minProfitBps, maxSlippageBps, paused);\r\n    }\r\n    \r\n    // Allow receiving ETH\r\n    receive() external payable {}\r\n}\r\n\r\n"
      },
      "project/contracts/MultiDexExecutor.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n * 沐 MULTI-DEX EXECUTOR CONTRACT\r\n * 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n * \r\n * Ejecutor optimizado para arbitraje entre mﾃｺltiples DEXs.\r\n * Soporta: Uniswap V3, SushiSwap, Curve, Balancer\r\n * \r\n * Caracterﾃｭsticas:\r\n * - Ejecuciﾃｳn atﾃｳmica multi-swap\r\n * - Simulaciﾃｳn on-chain antes de ejecutar\r\n * - MEV Protection con deadline y slippage\r\n * - Profit validation\r\n */\r\n\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n// INTERFACES\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256) external;\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV3Router {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n    \r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n}\r\n\r\ninterface IUniswapV3Quoter {\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n}\r\n\r\ninterface ISushiRouter {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    \r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface ICurvePool {\r\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\r\n}\r\n\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n// MAIN CONTRACT\r\n// 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n\r\ncontract MultiDexExecutor {\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // STATE VARIABLES\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    address public owner;\r\n    \r\n    // DEX Addresses\r\n    address public uniswapV3Router;\r\n    address public uniswapV3Quoter;\r\n    address public sushiRouter;\r\n    \r\n    // Tokens\r\n    address public WETH;\r\n    address public USDC;\r\n    address public USDT;\r\n    address public DAI;\r\n    \r\n    // Stats\r\n    uint256 public totalTrades;\r\n    uint256 public successfulTrades;\r\n    uint256 public totalProfitWei;\r\n    \r\n    // Config\r\n    uint256 public minProfitWei = 0; // Minimum profit in wei\r\n    uint256 public maxSlippageBps = 100; // 1%\r\n    bool public paused = false;\r\n    \r\n    // DEX enum\r\n    enum DEX { UNISWAP_V3, SUSHISWAP, CURVE }\r\n    \r\n    // Swap instruction\r\n    struct SwapInstruction {\r\n        DEX dex;\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        uint256 minAmountOut;\r\n        uint24 fee; // For Uniswap V3\r\n        bytes extraData; // For Curve pool index, etc.\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // EVENTS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    event TradeExecuted(\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOut,\r\n        uint256 profit,\r\n        DEX dex\r\n    );\r\n    \r\n    event MultiSwapExecuted(\r\n        uint256 swapCount,\r\n        uint256 totalProfit,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event ProfitWithdrawn(address indexed token, uint256 amount);\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // MODIFIERS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier notPaused() {\r\n        require(!paused, \"Contract paused\");\r\n        _;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // CONSTRUCTOR\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    constructor(\r\n        address _uniswapV3Router,\r\n        address _uniswapV3Quoter,\r\n        address _sushiRouter,\r\n        address _weth,\r\n        address _usdc\r\n    ) {\r\n        owner = msg.sender;\r\n        uniswapV3Router = _uniswapV3Router;\r\n        uniswapV3Quoter = _uniswapV3Quoter;\r\n        sushiRouter = _sushiRouter;\r\n        WETH = _weth;\r\n        USDC = _usdc;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // SINGLE SWAP FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Execute a single swap on Uniswap V3\r\n     */\r\n    function swapUniswapV3(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 minAmountOut,\r\n        uint24 fee\r\n    ) public onlyOwner notPaused returns (uint256 amountOut) {\r\n        IERC20(tokenIn).approve(uniswapV3Router, amountIn);\r\n        \r\n        amountOut = IUniswapV3Router(uniswapV3Router).exactInputSingle(\r\n            IUniswapV3Router.ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: fee,\r\n                recipient: address(this),\r\n                amountIn: amountIn,\r\n                amountOutMinimum: minAmountOut,\r\n                sqrtPriceLimitX96: 0\r\n            })\r\n        );\r\n        \r\n        totalTrades++;\r\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOut, 0, DEX.UNISWAP_V3);\r\n        \r\n        return amountOut;\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute a single swap on SushiSwap\r\n     */\r\n    function swapSushiSwap(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint256 minAmountOut\r\n    ) public onlyOwner notPaused returns (uint256 amountOut) {\r\n        IERC20(tokenIn).approve(sushiRouter, amountIn);\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n        \r\n        uint[] memory amounts = ISushiRouter(sushiRouter).swapExactTokensForTokens(\r\n            amountIn,\r\n            minAmountOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp + 300\r\n        );\r\n        \r\n        amountOut = amounts[amounts.length - 1];\r\n        totalTrades++;\r\n        \r\n        emit TradeExecuted(tokenIn, tokenOut, amountIn, amountOut, 0, DEX.SUSHISWAP);\r\n        \r\n        return amountOut;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // ARBITRAGE FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Execute cross-DEX arbitrage: Buy on one DEX, sell on another\r\n     */\r\n    function executeCrossDexArbitrage(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountIn,\r\n        DEX buyDex,\r\n        DEX sellDex,\r\n        uint24 uniFee,\r\n        uint256 minProfit\r\n    ) external onlyOwner notPaused returns (uint256 profit) {\r\n        uint256 balanceBefore = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceBefore >= amountIn, \"Insufficient balance\");\r\n        \r\n        uint256 intermediateAmount;\r\n        uint256 finalAmount;\r\n        \r\n        // Step 1: Buy tokenB with tokenA\r\n        if (buyDex == DEX.UNISWAP_V3) {\r\n            intermediateAmount = swapUniswapV3(tokenA, tokenB, amountIn, 0, uniFee);\r\n        } else if (buyDex == DEX.SUSHISWAP) {\r\n            intermediateAmount = swapSushiSwap(tokenA, tokenB, amountIn, 0);\r\n        }\r\n        \r\n        // Step 2: Sell tokenB for tokenA\r\n        if (sellDex == DEX.UNISWAP_V3) {\r\n            finalAmount = swapUniswapV3(tokenB, tokenA, intermediateAmount, amountIn, uniFee);\r\n        } else if (sellDex == DEX.SUSHISWAP) {\r\n            finalAmount = swapSushiSwap(tokenB, tokenA, intermediateAmount, amountIn);\r\n        }\r\n        \r\n        // Calculate profit\r\n        uint256 balanceAfter = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceAfter > balanceBefore, \"No profit\");\r\n        \r\n        profit = balanceAfter - balanceBefore;\r\n        require(profit >= minProfit, \"Profit below minimum\");\r\n        \r\n        totalProfitWei += profit;\r\n        successfulTrades++;\r\n        \r\n        emit MultiSwapExecuted(2, profit, block.timestamp);\r\n        \r\n        return profit;\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute intra-DEX arbitrage: Different fee tiers on Uniswap V3\r\n     */\r\n    function executeIntraDexArbitrage(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountIn,\r\n        uint24 fee1,\r\n        uint24 fee2,\r\n        uint256 minProfit\r\n    ) external onlyOwner notPaused returns (uint256 profit) {\r\n        uint256 balanceBefore = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceBefore >= amountIn, \"Insufficient balance\");\r\n        \r\n        // Step 1: Swap A -> B with fee1\r\n        uint256 intermediateAmount = swapUniswapV3(tokenA, tokenB, amountIn, 0, fee1);\r\n        \r\n        // Step 2: Swap B -> A with fee2\r\n        uint256 finalAmount = swapUniswapV3(tokenB, tokenA, intermediateAmount, amountIn, fee2);\r\n        \r\n        // Calculate profit\r\n        uint256 balanceAfter = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceAfter > balanceBefore, \"No profit\");\r\n        \r\n        profit = balanceAfter - balanceBefore;\r\n        require(profit >= minProfit, \"Profit below minimum\");\r\n        \r\n        totalProfitWei += profit;\r\n        successfulTrades++;\r\n        \r\n        emit MultiSwapExecuted(2, profit, block.timestamp);\r\n        \r\n        return profit;\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute triangular arbitrage: A -> B -> C -> A\r\n     */\r\n    function executeTriangularArbitrage(\r\n        address tokenA,\r\n        address tokenB,\r\n        address tokenC,\r\n        uint256 amountIn,\r\n        uint24 feeAB,\r\n        uint24 feeBC,\r\n        uint24 feeCA,\r\n        uint256 minProfit\r\n    ) external onlyOwner notPaused returns (uint256 profit) {\r\n        uint256 balanceBefore = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceBefore >= amountIn, \"Insufficient balance\");\r\n        \r\n        // Step 1: A -> B\r\n        uint256 amountB = swapUniswapV3(tokenA, tokenB, amountIn, 0, feeAB);\r\n        \r\n        // Step 2: B -> C\r\n        uint256 amountC = swapUniswapV3(tokenB, tokenC, amountB, 0, feeBC);\r\n        \r\n        // Step 3: C -> A\r\n        uint256 finalAmount = swapUniswapV3(tokenC, tokenA, amountC, amountIn, feeCA);\r\n        \r\n        // Calculate profit\r\n        uint256 balanceAfter = IERC20(tokenA).balanceOf(address(this));\r\n        require(balanceAfter > balanceBefore, \"No profit\");\r\n        \r\n        profit = balanceAfter - balanceBefore;\r\n        require(profit >= minProfit, \"Profit below minimum\");\r\n        \r\n        totalProfitWei += profit;\r\n        successfulTrades++;\r\n        \r\n        emit MultiSwapExecuted(3, profit, block.timestamp);\r\n        \r\n        return profit;\r\n    }\r\n    \r\n    /**\r\n     * @notice Execute multi-swap in a single transaction\r\n     */\r\n    function executeMultiSwap(\r\n        SwapInstruction[] calldata swaps,\r\n        uint256 minFinalBalance\r\n    ) external onlyOwner notPaused returns (uint256 finalBalance) {\r\n        require(swaps.length > 0, \"No swaps\");\r\n        \r\n        address startToken = swaps[0].tokenIn;\r\n        uint256 startBalance = IERC20(startToken).balanceOf(address(this));\r\n        \r\n        uint256 currentAmount = swaps[0].amountIn;\r\n        \r\n        for (uint256 i = 0; i < swaps.length; i++) {\r\n            SwapInstruction memory swap = swaps[i];\r\n            \r\n            if (swap.dex == DEX.UNISWAP_V3) {\r\n                currentAmount = swapUniswapV3(\r\n                    swap.tokenIn,\r\n                    swap.tokenOut,\r\n                    currentAmount,\r\n                    swap.minAmountOut,\r\n                    swap.fee\r\n                );\r\n            } else if (swap.dex == DEX.SUSHISWAP) {\r\n                currentAmount = swapSushiSwap(\r\n                    swap.tokenIn,\r\n                    swap.tokenOut,\r\n                    currentAmount,\r\n                    swap.minAmountOut\r\n                );\r\n            }\r\n        }\r\n        \r\n        // Verify we ended with the same token and profit\r\n        address endToken = swaps[swaps.length - 1].tokenOut;\r\n        require(endToken == startToken, \"Must end with start token\");\r\n        \r\n        finalBalance = IERC20(startToken).balanceOf(address(this));\r\n        require(finalBalance >= minFinalBalance, \"Below minimum final balance\");\r\n        require(finalBalance > startBalance, \"No profit\");\r\n        \r\n        uint256 profit = finalBalance - startBalance;\r\n        totalProfitWei += profit;\r\n        successfulTrades++;\r\n        \r\n        emit MultiSwapExecuted(swaps.length, profit, block.timestamp);\r\n        \r\n        return finalBalance;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // QUOTE FUNCTIONS (for simulation)\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    /**\r\n     * @notice Get quote from Uniswap V3\r\n     */\r\n    function quoteUniswapV3(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn,\r\n        uint24 fee\r\n    ) external returns (uint256 amountOut) {\r\n        return IUniswapV3Quoter(uniswapV3Quoter).quoteExactInputSingle(\r\n            tokenIn,\r\n            tokenOut,\r\n            fee,\r\n            amountIn,\r\n            0\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @notice Get quote from SushiSwap\r\n     */\r\n    function quoteSushiSwap(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 amountIn\r\n    ) external view returns (uint256 amountOut) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = tokenIn;\r\n        path[1] = tokenOut;\r\n        \r\n        uint[] memory amounts = ISushiRouter(sushiRouter).getAmountsOut(amountIn, path);\r\n        return amounts[amounts.length - 1];\r\n    }\r\n    \r\n    /**\r\n     * @notice Simulate arbitrage and return expected profit\r\n     */\r\n    function simulateArbitrage(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountIn,\r\n        uint24 fee1,\r\n        uint24 fee2\r\n    ) external returns (int256 expectedProfit) {\r\n        // Quote first swap\r\n        uint256 intermediateAmount = IUniswapV3Quoter(uniswapV3Quoter).quoteExactInputSingle(\r\n            tokenA,\r\n            tokenB,\r\n            fee1,\r\n            amountIn,\r\n            0\r\n        );\r\n        \r\n        // Quote second swap\r\n        uint256 finalAmount = IUniswapV3Quoter(uniswapV3Quoter).quoteExactInputSingle(\r\n            tokenB,\r\n            tokenA,\r\n            fee2,\r\n            intermediateAmount,\r\n            0\r\n        );\r\n        \r\n        return int256(finalAmount) - int256(amountIn);\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // ADMIN FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    function setTokens(address _weth, address _usdc, address _usdt, address _dai) external onlyOwner {\r\n        WETH = _weth;\r\n        USDC = _usdc;\r\n        USDT = _usdt;\r\n        DAI = _dai;\r\n    }\r\n    \r\n    function setRouters(\r\n        address _uniRouter,\r\n        address _uniQuoter,\r\n        address _sushiRouter\r\n    ) external onlyOwner {\r\n        uniswapV3Router = _uniRouter;\r\n        uniswapV3Quoter = _uniQuoter;\r\n        sushiRouter = _sushiRouter;\r\n    }\r\n    \r\n    function setMinProfitWei(uint256 _minProfitWei) external onlyOwner {\r\n        minProfitWei = _minProfitWei;\r\n    }\r\n    \r\n    function setMaxSlippageBps(uint256 _maxSlippageBps) external onlyOwner {\r\n        require(_maxSlippageBps <= 500, \"Max 5%\");\r\n        maxSlippageBps = _maxSlippageBps;\r\n    }\r\n    \r\n    function setPaused(bool _paused) external onlyOwner {\r\n        paused = _paused;\r\n    }\r\n    \r\n    function withdrawToken(address token) external onlyOwner {\r\n        uint256 balance = IERC20(token).balanceOf(address(this));\r\n        require(balance > 0, \"No balance\");\r\n        IERC20(token).transfer(owner, balance);\r\n        emit ProfitWithdrawn(token, balance);\r\n    }\r\n    \r\n    function withdrawETH() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(balance > 0, \"No ETH\");\r\n        payable(owner).transfer(balance);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    // VIEW FUNCTIONS\r\n    // 笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊絶武笊申r\n    \r\n    function getStats() external view returns (\r\n        uint256 _totalTrades,\r\n        uint256 _successfulTrades,\r\n        uint256 _totalProfitWei\r\n    ) {\r\n        return (totalTrades, successfulTrades, totalProfitWei);\r\n    }\r\n    \r\n    function getConfig() external view returns (\r\n        uint256 _minProfitWei,\r\n        uint256 _maxSlippageBps,\r\n        bool _paused\r\n    ) {\r\n        return (minProfitWei, maxSlippageBps, paused);\r\n    }\r\n    \r\n    function getBalances() external view returns (\r\n        uint256 ethBalance,\r\n        uint256 wethBalance,\r\n        uint256 usdcBalance\r\n    ) {\r\n        ethBalance = address(this).balance;\r\n        wethBalance = WETH != address(0) ? IERC20(WETH).balanceOf(address(this)) : 0;\r\n        usdcBalance = USDC != address(0) ? IERC20(USDC).balanceOf(address(this)) : 0;\r\n    }\r\n    \r\n    // Allow receiving ETH\r\n    receive() external payable {}\r\n}\r\n\r\n"
      }
    }
  }
}